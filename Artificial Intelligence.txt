                                                                          Artificial Intelligence for beginners 
                                                                          
                                                                          
 Neural network and deep learning are the core of modern AI: Neural architecture is used for work with image and text.
 

 Weak AI (Narrow AI)
 Definition:

AI systems designed and trained for a specific task.

They do not possess consciousness, genuine understanding, or self-awareness.

 Key Features:

Perform limited, narrow functions.

Operate within predefined parameters.

Cannot truly understand meaning or context the way humans do.

 Examples:

Siri, Alexa, or Google Assistant

Chatbots

Image recognition software

Spam filters

Recommendation systems (Netflix, YouTube, Amazon)

 Alternate Names:

Narrow AI

Applied AI

Strong AI (Artificial General Intelligence – AGI)
 Definition:

AI with human-level (or beyond) cognitive abilities.

Capable of understanding, reasoning, and learning across any domain, just like a human.

 Key Features:

Consciousness or awareness (theoretical)

Understands context and meaning

Can solve problems it wasn’t explicitly programmed for

Has flexible, general intelligence

 Examples:

None exist yet. Strong AI is still theoretical.

 Alternate Names:

Artificial General Intelligence (AGI)

Full AI

Human-level AI

Turing test:- The Turing Test is a method proposed by Alan Turing in 1950 to answer the question:

“Can machines think?”

Instead of directly defining “thinking,” Turing suggested a practical test.

How the Turing Test Works
Imagine a human judge chatting (usually via text) with:

A human, and

A machine (computer program or AI)

The conversations happen blindly:

The judge doesn’t know who’s human and who’s the machine.

The judge asks any questions they want.

 The machine passes the Turing Test if:

The judge cannot reliably tell the machine apart from the human based on the conversation.


             Turing Test in simple words = A game to see if you can tell a human from a machine by chatting with them.
             
             
     Top-Down Approach(Symbolic reasoning)
Definition:

Start from the big picture or overall system.

Break it down into smaller parts or detailed steps.

How it works:

Understand the whole system or goal.

Divide it into major components.

Keep breaking each part into smaller tasks until you reach the simplest level.

Advantages:

Clear vision of the overall goal.

Good for planning large systems.

Helps keep work organized.

Examples:

Designing software by first planning overall architecture, then coding individual modules.

Writing an essay by outlining main sections first, then filling in details.

Management planning company goals first, then assigning tasks to departments.

   Bottom-Up Approach(Neural Network)
Definition:

Start with small, simple parts.

Combine them to build more complex systems.

How it works:

Create or analyze small, basic units.

Integrate them to form bigger structures.

Keep combining until you achieve the full system.

Advantages:

Often leads to reusable, flexible components.

Good for exploring unknown problems.

Encourages innovation in small parts.

Examples:

Writing small functions first, then combining them into a program.

Learning letters and sounds before forming words and sentences.

Scientists studying atoms and molecules to understand larger materials.

Machine learning:- Part of Artificial Intelligence that is based on computer learning to solve a problem based on some data is called Machine Learning. 

Computer knowledge representation:-
Network representations are based on the fact that we have a network of interrelated concepts inside our head. We can try to reproduce the same networks as a graph inside a computer - a so-called semantic network. In simple words a semantic network is a way of representing knowledge using a graph of nodes and links:

Nodes → represent concepts, objects, ideas, or words (e.g. Cat, Animal, Has Fur).
Links (edges) → represent relationships between those concepts (e.g. is-a, has, part-of).

1.Object-Attribute-Value triplets or attribute-value pairs:- Since a graph can be represented inside a computer as a list of nodes and edges, we can represent a semantic network by a list of triplets, containing objects, attributes, and values. For example, ollowing triplets about programming languages:


_______________________________________________________________________________
|Object	         |      Attribute	   |                   Value                |
|Python	         |        is         |               Untyped-Language         |
|Python	         |   invented-by     |         	    Guido van Rossum          |
|Python	         |   block-syntax    |               	indentation             |
|Untyped-Language|	 doesn't have	   |               type definitions         |
_______________________________________________________________________________

2.Hierarchical representations are ways of organizing information in a tree-like structure, where elements are arranged at different levels of importance, generality, or specificity.

Key ideas:

Levels of hierarchy — concepts at the top are broader or more general, while those lower down are more specific.

 Parent-child relationships — higher-level concepts act as “parents,” and lower-level concepts are their “childrenff

 Single path upward — each item (except the topmost) has one direct parent.
For ex.


            Animal
          /        \
       Mammal      Bird
      /      \         \
    Dog      Cat      Sparrow

Animal is the most general concept.

Mammal and Bird are subcategories.

Dog, Cat, and Sparrow are specific examples.


A frame representation is a way of storing knowledge using data structures called frames. Each frame represents a concept, object, situation, or event, and contains slots that hold information about its attributes and relationships.
Scenarios are special kind of frames that represent complex situations that can unfold in time.

Frame: Car
-------------------------
Type         : Vehicle
Color        : Red
Wheels       : 4
Engine-Type  : Petrol
Owner        : John

+----------------+---------------------+----------------+------------------+
| Slot           | Value               | Default value  | Interval         |
+----------------+---------------------+----------------+------------------+
| Name           | Python              |                |                  |
| Is-A           | Untyped-Language    |                |                  |
| Variable Case  |                     | CamelCase      |                  |
| Program Length |                     |                | 5-5000 lines     |
| Block Syntax   | Indent              |                |                  |
+----------------+---------------------+----------------+------------------+

3.Procedural representations are based on representing knowledge by a list of actions that can be executed when a certain condition occurs.

Production rules are if-then statements that allow us to draw conclusions. For example, a doctor can have a rule saying that IF a patient has high fever OR high level of C-reactive protein in blood test THEN he has an inflammation. Once we encounter one of the conditions, we can make a conclusion about inflammation, and then use it in further reasoning.
Algorithms can be considered another form of procedural representation, although they are almost never used directly in knowledge-based systems.
Predicate Logic (also called First-Order Logic) is a way to represent knowledge using predicates, variables, and quantifiers. It’s more powerful than simple true/false statements because it can describe relationships and properties of objects.


Basic Components
Predicate → expresses a property or a relationship.

Example:

Tall(John) → “John is tall.”

Loves(Alice, Bob) → “Alice loves Bob.”

 Variables → stand for objects.

Example: x, y, z

 Constants → specific objects.

Example: John, Bob

 Quantifiers → state how many things satisfy a condition:

Universal quantifier ( ∀ ) → “for all”

∀x Tall(x) → “Everyone is tall.”

Existential quantifier ( ∃ ) → “there exists”

∃x Tall(x) → “Someone is tall.”

4.Logic was originally proposed by Aristotle as a way to represent universal human knowledge.

Predicate Logic as a mathematical theory is too rich to be computable, therefore some subset of it is normally used, such as Horn clauses used in Prolog.
Descriptive Logic is a family of logical systems used to represent and reason about hierarchies of objects distributed knowledge representations such as semantic web.
Description Logic (DL) is a family of formal logics used to represent structured knowledge and reason about it. It's widely used in semantic web, ontology design, and knowledge-based systems.

What is an Expert System?
An expert system is a type of Artificial Intelligence (AI) program that mimics the decision-making ability of a human expert.
It uses:

Rules

Facts

Reasoning techniques

to solve problems that usually require human expertise.

How does it work?
An expert system has two main parts:

Part	               |                  What it does
Knowledge Base	     |       Stores facts and rules from human experts.
Inference Engine	   |       Applies rules to facts to draw conclusions.


Forward vs. Backward Inference:
Forward inference is a reasoning method that:

 Starts with known facts
 Applies rules to those facts
Generates new facts or conclusions

→ It’s data-driven reasoning.
How does it work?
Look at all known facts.

Check which rules can “fire” (i.e. whose conditions are satisfied).

Apply those rules to produce new facts.

Repeat the process until:

No more rules apply, OR

A goal is reached.
Rule 1: IF sky_is_cloudy THEN it_might_rain
Rule 2: IF it_might_rain THEN carry_umbrella

Backward inference is a reasoning method that:

 Starts with a goal or question
 Works backward through rules
 Tries to prove the goal using known facts

→ It’s goal-driven reasoning.

How does it work?
Start with what you want to prove (the goal).

Look for rules whose conclusions match the goal.

For each rule, check whether its conditions are true:

If conditions are facts → goal proven!

If not → treat conditions as new sub-goals and try to prove them.

Repeat until:

The goal is proven, OR

It’s impossible to prove.

Rule 1: IF sky_is_cloudy THEN it_might_rain
Rule 2: IF it_might_rain THEN carry_umbrella


